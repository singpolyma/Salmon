#!/usr/bin/env python
#
# Copyright 2008 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

"""Data model for the Salmon Playground"""

import datetime
import hashlib
import logging

from google.appengine.ext import db

class Entry(db.Model):
  """Generic RSS/Atom feed entry.  Semantics are mostly
     those of atom:entry.  Any Entry can be either a
     standalone post or a Salmon (a reply to a post).
     A Salmon always has a topic_id, which is just the
     id of a standalone post which is the ultimate
     ancestor/topic of the salmon.
  """
  entry_id = db.StringProperty(indexed=True)    #atom:id
  in_reply_to = db.StringProperty(indexed=True) #thr:in_reply_to@href
  topic_id = db.StringProperty(indexed=True)    #standalone post this salmon replies to
  updated = db.DateTimeProperty()               #atom:updated
  author_uri = db.StringProperty()              #atom:author/uri
  title = db.StringProperty()                   #atom:title
  content = db.TextProperty()                   #atom:content
  thread_updated = db.DateTimeProperty()        #thr:updated
  link = db.StringProperty()                    #atom:link@rel="alternate"@href
  author_name = db.StringProperty()             #atom:author/name
  salmonendpoint = db.StringProperty()          #link@rel="salmon"@href
  signature = db.StringProperty()               #salmon:signature

def getLinkRel(fields,relval):
  """Given bag of parsed fields, returns list of links where the rel value matches,
     or an empty list if there are no matches.
  """
  if fields and fields.get('links'):
    # TODO: Can there be multiple rel names in an elem.rel?  Double check.
    return [elem for elem in fields.get('links') if elem.get('rel') == relval]
  else:
    return []

def getSalmonEndpoint(entryfields,feedfields):
  """Determines Salmon endpoint, if any, for the given entry in the given feed.
     Returns None if none found.
  """
  # Figure out the Salmon endpoint to use for this entry in the future.  Precedence rules:
  # Use entry's salmon endpoint if present, else use entry's atom:source feed salmon endpoint,
  # else use enclosing feed's salmon endpoint.
  el = getLinkRel(entryfields,"salmon")
  if entryfields.get('source'):
     el.extend(getLinkRel(entryfields.source,"salmon"))
  #logging.info('About to get salmon link for feed %s',feedfields)
  if feedfields:
    el.extend(getLinkRel(feedfields,"salmon"))
  logging.info("Found salmon endpoints for %s: %s",getLinkRel(feedfields,'self'),el)
  # For now, return the first link in the list generated by this procedure.  Multiple Salmon
  # endpoints is an interesting extension for the future.
  return el[0].get('href') if el else None

def makeEntry(fields, feedfields=None):
  """Creates an Entry from entry fields in feedparser.py format"""
  logging.info('In makeEntry')
  if hasattr(fields, 'content'):
    # This is Atom.
    content = fields.content[0].value
  else:
    content = fields.get('description', '')

  # Grab the primary link (atom:link@rel="alternate") for the entry, and its
  # globally persistently unique ID for disambiguation/de-duping/future reference.
  link = fields.get('link', '')
  entry_id = (fields.get('id', '') or link)

  # Grab additional interesting content and map to internal representation.
  title = fields.get('title', '').split('\n')[0]
  updated_parsed = fields.updated_parsed
  author_detail = fields.get('author_detail','')
  author_name = author_detail.get('name','(anonymous)') if author_detail else ''
  author_uri = author_detail.get('href','') if author_detail else ''  # What URI do you use for anonymous?
  updated_tm = datetime.datetime(*updated_parsed[0:5])
  signature = (fields.get("signature") or None)
  endpoint = getSalmonEndpoint(fields,feedfields)
  in_reply_to = fields.get('in-reply-to') or None # TODO: Fix feedparser to retain href from in-reply-to?

  logging.info('entry id = %s',entry_id)
  e = Entry(key_name='key_' + hashlib.sha1(entry_id).hexdigest(),
            entry_id=entry_id,
            title=title,
            content=content,
            link=link,
            author_name=author_name,
            author_uri=author_uri,
            updated=updated_tm,
            thread_updated=updated_tm,
            salmonendpoint=endpoint,
            topic_id=entry_id,
            in_reply_to=in_reply_to)

  logging.info('About to return entry %s',e)

  return e

#TODO: Is "Topic" too confusing compared to PuSH usage?
def getTopicsOf(e):
  # Gets top level ancestors (parents) in the in-reply-to
  # graph for the given salmon e
  topics = Entry.all()
  logging.info("Getting parents with topic equal to %s",e.in_reply_to)
  topics.filter("topic_id = ", unicode(e.in_reply_to)) #TODO: Deal with salmon on salmon
  return topics

def getLatestPosts(N):
  """Retrieves latest top level posts/topics"""
  return Entry.gql('WHERE in_reply_to = :1 ORDER BY thread_updated DESC',None).fetch(N)

def getRepliesTo(e,N):
  return Entry.gql('WHERE in_reply_to=:1 ORDER BY updated',e.entry_id).fetch(N)

def getEntryById(id):
  entries=Entry.gql('WHERE entry_id=:1 ORDER BY updated',id).fetch(1)
  return entries[0]
